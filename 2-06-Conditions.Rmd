# Conditions

## Signalling conditions

1.  __<span style="color:red">Q</span>__: Write a wrapper around `file.remove()` that throws an error if the file to be deleted does not exist.

2.  __<span style="color:red">Q</span>__: What does the `appendLF` argument to `message()` do? How is it related to `cat()`?

3.  __<span style="color:red">Q</span>__: What does `options(error = recover)` do? Why might you use it?

4.  __<span style="color:red">Q</span>__: What does `options(error = quote(dump.frames(to.file = TRUE)))` do? Why might you use it?

## Handling conditions

1.  __<span style="color:red">Q</span>__: Predict the results of evaluating the following code

    ```{r, eval = FALSE}
    show_condition <- function(code) {
      tryCatch(
        error = function(cnd) "error",
        warning = function(cnd) "warning",
        message = function(cnd) "message",
        {
          code
          NULL
        }
      )
    }
    
    show_condition(stop("!"))
    show_condition(10)
    show_condition(warning("?!"))
    show_condition({
      10
      message("?")
      warning("?!")
    })
    ```

1.  __<span style="color:red">Q</span>__: Explain the results of running this code:

    ```{r}
    withCallingHandlers(
      message = function(cnd) message("b"),
      withCallingHandlers(
        message = function(cnd) message("a"),
        message("c")
      )
    )
    ```

1.  __<span style="color:red">Q</span>__: Read the source code for `catch_cnd()` and explain how it works.

1.  __<span style="color:red">Q</span>__: How could you rewrite `show_condition()` to use a single handler?

## Custom conditions

1.  __<span style="color:red">Q</span>__: Inside a package, itâ€™s occassionally useful to check that a package is installed before using it. Write a function that checks if a package is installed (with `requireNamespace("pkg", quietly = FALSE))` and if not, throws a custom condition that includes the package name in the metadata.

1.  __<span style="color:red">Q</span>__: Inside a package you often need to stop with an error when something is not right. Other packages that depend on your package might be tempted to check these errors in their unit tests. How could you help these packages to avoid relying on the error message which is part of the user interface rather than the API and might change without notice?

## Applications

1.  __<span style="color:red">Q</span>__: Create `suppressConditions()` that works like `suppressMessages()` and `supressWarnings()` but supresses everything. Think carefully about how you should handle errors.

1.  __<span style="color:red">Q</span>__: Compare the following two implementations of `message2error()`. What is the
    main advantage of `withCallingHandlers()` in this scenario? (Hint: look
    carefully at the traceback.)

    ```{r}
    message2error <- function(code) {
      withCallingHandlers(code, message = function(e) stop(e))
    }
    message2error <- function(code) {
      tryCatch(code, message = function(e) stop(e))
    }
    ```
    
    __<span style="color:green">A</span>__: 
    
1.  __<span style="color:red">Q</span>__:  How would you modify the `catch_cnds()` defined if you wanted to recreate
    the original intermingling of warnings and messages?

1.  __<span style="color:red">Q</span>__:  Why is catching interrupts dangerous? Run this code to find out.

    ```{r, eval = FALSE}
    bottles_of_beer <- function(i = 99) {
      message("There are ", i, " bottles of beer on the wall, ", i, " bottles of beer.")
      while(i > 0) {
        tryCatch(
          Sys.sleep(1),
          interrupt = function(err) {
            i <<- i - 1
            if (i > 0) {
              message(
                "Take one down, pass it around, ", i, 
                " bottle", if (i > 1) "s", " of beer on the wall."
              )
            }
          }
        )
      }
      message("No more bottles of beer on the wall, no more bottles of beer.")
    }
    ```

