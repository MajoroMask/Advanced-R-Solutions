```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = TRUE
)
```
```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = TRUE
)
```
# Evaluation

## Introduction

1.  __<span style="color:red">Q</span>__: Carefully read the documentation for `source()`. What environment does it
    use by default? What if you supply `local = TRUE`? How do you provide 
    a custom argument?
    
    __<span style="color:green">A</span>__:
    
    ```{r}
    tmp <- tempfile()
    writeLines("print(x)", tmp)  # create a temporary R-script

    x <- 2

    local({
      x <- 3
      source(tmp, local = FALSE)
    })    
    
    local({
      x <- 3
      source(tmp, local = TRUE)
    })
    
    env2 <- rlang::env(x = 4)
    local({
      x <- 3
      source(tmp, local = env2)
    })
    
    # Alternative:
    source_local <- function(file, local){
      local({
        x <- 3
        source(file, local = local)
      })      
    }
    
    source_local(tmp, FALSE)
    source_local(tmp, TRUE)
    source_local(tmp, env2)
    ```
    
    By default, the global environment is used, but also a local environment can be used. It is also possible to defince a specific environment by passing an environmen-object to `source`.
    
    [When would this be useful? usecases?]
    [should a better example, than 2,3,4 be used?]


1.  __<span style="color:red">Q</span>__: Predict the results of the following lines of code:

    ```{r, eval = FALSE}
    eval(quote(eval(quote(eval(quote(2 + 2))))))        # -> 4
    eval(eval(quote(eval(quote(eval(quote(2 + 2)))))))  # -> 4
    quote(eval(quote(eval(quote(eval(quote(2 + 2))))))) 
        # eval(quote(eval(quote(eval(quote(2 + 2))))))
    ```


    __<span style="color:green">A</span>__: An outside `quote()` always wins...

1.  __<span style="color:red">Q</span>__: Write an equivalent to `get()` using `sym()` and `eval_bare()`. Write an
    equivalent to `assign()` using `sym()`, `expr()`, and `eval_bare()`.
    (Don't worry about the multiple ways of choosing an environment that
    `get()` and `assign()` support; assume that the user supplies it 
    explicitly.)
    
    ```{r}
    # name is a string
    get2 <- function(name, env) {}
    assign2 <- function(name, value, env) {}
    ```
    
    __<span style="color:green">A</span>__:   

    ```{r}
    # name is a string
    get2 <- function(name, env) {}
    assign2 <- function(name, value, env) {}
    ```

1.  __<span style="color:red">Q</span>__: Modify `source2()` so it returns the result of _every_ expression,
    not just the last one. Can you eliminate the for loop?

1.  __<span style="color:red">Q</span>__: The code generated by `source2()` lacks source references. Read
    the source code for `sys.source()` and the help for `srcfilecopy()`,
    then modify `source2()` to preserve source references. You can
    test your code by sourcing a function that contains a comment. If
    successful, when you look at the function, you'll see the comment and
    not just the source code.

1.  __<span style="color:red">Q</span>__: The third argument in `subset()` allows you to select variables. It
    treats variable names as if they were positions. This allows you to do 
    things like `subset(mtcars, , -cyl)` to drop the cylinder variable, or
    `subset(mtcars, , disp:drat)` to select all the variables between `disp`
    and `drat`. How does this work? I've made this easier to understand by
    extracting it out into its own function that uses tidy evaluation.

    ```{r, eval = FALSE}
    select <- function(df, vars) {
      vars <- enexpr(vars)
      var_pos <- set_names(as.list(seq_along(df)), names(df))
      
      cols <- eval_tidy(vars, var_pos)
      df[, cols, drop = FALSE]
    }
    select(mtcars, -cyl)
    ```

1.  __<span style="color:red">Q</span>__: We can make `base::local()` slightly easier to understand by spreading
    out over multiple lines:

    ```{r}
    local3 <- function(expr, envir = new.env()) {
      call <- substitute(eval(quote(expr), envir))
      eval(call, envir = parent.frame())
    }
    ```
    
    Explain how `local()` works in words. (Hint: you might want to `print(call)`
    to help understand what `substitute()` is doing, and read the documentation
    to remind yourself what environment `new.env()` will inherit from.)
    
## Quosures

1.  __<span style="color:red">Q</span>__: Predict what evaluating each of the following quosures will return.

    ```{r}
    library(rlang)
    
    q1 <- new_quosure(expr(x), env(x = 1))
    q1
    
    q2 <- new_quosure(expr(x + !!q1), env(x = 10))
    q2
    
    q3 <- new_quosure(expr(x + !!q2), env(x = 100))
    q3
    ```
    
    __<span style="color:green">A</span>__: Each quosure will be evaluated in it's own environment. Hence we get:
    
    ```{r}
    eval_tidy(q1)
    eval_tidy(q2)
    eval_tidy(q3)
    ```

1.  __<span style="color:red">Q</span>__: Run this code in your head and predict what it will print. Confirm or 
    refute your prediction by running the code in R.

    ```{r, results = FALSE}
    f <- function(...) {
      x <- "f"
      g(f = x, ...)
    }
    g <- function(...) {
      x <- "g"
      h(g = x, ...)
    }
    h <- function(...) {
      enquos(...)
    }
    x <- "top"
    
    out <- f(top = x)
    out
    purrr::map_chr(out, eval_tidy)
    ```

## Tidy evaluation

1.  __<span style="color:red">Q</span>__: Improve `subset2()` to make it more like real subset function 
    (`subset.data.frame()`):
    
    * All drop rows where `subset` evaluates to `NA`
    * Give a clear error message if `subset` doesn't evalute to a logical vector
    * What happens if `subset` doesn't yield a logical vector with length
      equal to the number of rows in `data`? What do you think should happen?

1.  __<span style="color:red">Q</span>__: What happens if you use `expr()` instead of `enexpr()` inside of
    `subset2()`?

1.  __<span style="color:red">Q</span>__: Implement a form of `arrange()` where you can request a variable to 
    sorted in descending order using named arguments:
    
    ```{r, eval = FALSE}
    arrange(mtcars, cyl, desc = mpg, vs)
    ```
    
    (Hint:  The `descreasing` argument to `order()` will not help you. Instead,
    look at the definition of `dplyr::desc()`, and read the help for `xtfrm()`.)

1.  __<span style="color:red">Q</span>__: What does `transform()` do? Read the documentation. How does it work?
    Read the source code for `transform.data.frame()`. What does
    `substitute(list(...))` do?

1.  __<span style="color:red">Q</span>__: What does `with()` do? How does it work? Read the source code for
    `with.default()`. What does `within()` do? How does it work? Read the
    source code for `within.data.frame()`. Why is the code so much more
    complex than `with()`?

1.  __<span style="color:red">Q</span>__: Implement `with()` (code in `with.default()`).

1.  __<span style="color:red">Q</span>__: Implement a version of `within.data.frame()` that uses tidy evaluation.
    Read the documentation and make sure that you understand what `within()`
    does, then read the source code.

1.  __<span style="color:red">Q</span>__: Implement `transform()` (code in `transform.data.frame()`).  Extend it so that a
    variable can refer to the variables just defined.

## Case study: calling base NSE functions

### Exercises


## Capturing the current call {#capturing-call}

1.  __<span style="color:red">Q</span>__: Compare and contrast `update_model()` with `update.default()`.

1.  __<span style="color:red">Q</span>__: Why doesn't `write.csv(mtcars, "mtcars.csv", row = FALSE)` work?
    What property of argument matching has the original author forgotten?

1.  __<span style="color:red">Q</span>__: Rewrite `update.formula()` to use R code instead of C code.

1.  __<span style="color:red">Q</span>__: Sometimes it's necessary to uncover the function that called the
    function that called the current function (i.e., the grandparent, not
    the parent). How can you use `sys.call()` or `match.call()` to find
    this function?