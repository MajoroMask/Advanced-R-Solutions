```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = TRUE
)
```
```{r include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = TRUE
)
```
# Evaluation

## Introduction

1.  __<span style="color:red">Q</span>__: Carefully read the documentation for `source()`. What environment does it use by default? What if you supply `local = TRUE`? How do you provide a custom argument?
    
    __<span style="color:green">A</span>__: `source()` allows us to specify an evaluation environment. By default, the global environment is used. Using a local environment is possible, by setting `local = FALSE`. We may even provide a specific environment by passing an environment object.
    
    ```{r}
    # create temporary, sourcable R script
    tmp_file <- tempfile()
    writeLines("print(x)", tmp_file)
    
    # prepare testing "probes"
    x <- "global environment"
    
    locate_evaluation <- function(file, local){
      x <- "local environment"
      source(file, local = local)
    }
    
    env2 <- rlang::env(x = "specified envirionment")
    
    # where will source() be evaluated?
    locate_evaluation(tmp_file, local = FALSE)
    locate_evaluation(tmp_file, local = TRUE)
    locate_evaluation(tmp_file, local = env2)
    ```

1.  __<span style="color:red">Q</span>__: Predict the results of the following lines of code:

    ```{r, eval = FALSE}
    eval(quote(eval(quote(eval(quote(2 + 2))))))
    eval(eval(quote(eval(quote(eval(quote(2 + 2)))))))
    quote(eval(quote(eval(quote(eval(quote(2 + 2))))))) 
    ```

    __<span style="color:orange">A</span>__: You can see the output of the code above here:

    ```{r, echo = FALSE}
    eval(quote(eval(quote(eval(quote(2 + 2))))))
    eval(eval(quote(eval(quote(eval(quote(2 + 2)))))))
    quote(eval(quote(eval(quote(eval(quote(2 + 2)))))))
    ```

    Generally what happens, is that `2 + 2` is first quoted as an expression and than evaluated to `4`. When we nest calls to `quote()` and `eval()` more calls will be added to the AST, but the pattern of quoting and evaluating stays the same.

    ```{r}
    # pattern: evaluate a quoted expression
    eval(quote(
      eval(quote(
        eval(quote(
          2 + 2))
      ))
    ))
    
    lobstr::ast(eval(quote(eval(quote(eval(quote(2 + 2)))))))
    ```

    TODO (optional) Maybe explain a little better, in which order this call is evaluated, left to right or so?

    When we wrap this expression in another `eval()` the `4` will be evaluated once more, but the result doesn't change. When we quote it, we no evaluation takes place and we capture the expression instead. We could say: "An outside `quote()` always wins."

1.  __<span style="color:red">Q</span>__: Write an equivalent to `get()` using `sym()` and `eval_bare()`. Write an
    equivalent to `assign()` using `sym()`, `expr()`, and `eval_bare()`.
    (Don't worry about the multiple ways of choosing an environment that
    `get()` and `assign()` support; assume that the user supplies it 
    explicitly.)
    
    ```{r}
    # name is a string
    get2 <- function(name, env) {}
    assign2 <- function(name, value, env) {}
    ```
    
    __<span style="color:green">A</span>__:   

    ```{r}
    # name is a string
    get2 <- function(name, env) {}
    assign2 <- function(name, value, env) {}
    ```

1.  __<span style="color:red">Q</span>__: Modify `source2()` so it returns the result of _every_ expression,
    not just the last one. Can you eliminate the for loop?

1.  __<span style="color:red">Q</span>__: The code generated by `source2()` lacks source references. Read
    the source code for `sys.source()` and the help for `srcfilecopy()`,
    then modify `source2()` to preserve source references. You can
    test your code by sourcing a function that contains a comment. If
    successful, when you look at the function, you'll see the comment and
    not just the source code.

1.  __<span style="color:red">Q</span>__: The third argument in `subset()` allows you to select variables. It
    treats variable names as if they were positions. This allows you to do 
    things like `subset(mtcars, , -cyl)` to drop the cylinder variable, or
    `subset(mtcars, , disp:drat)` to select all the variables between `disp`
    and `drat`. How does this work? I've made this easier to understand by
    extracting it out into its own function that uses tidy evaluation.

    ```{r, eval = FALSE}
    select <- function(df, vars) {
      vars <- enexpr(vars)
      var_pos <- set_names(as.list(seq_along(df)), names(df))
      
      cols <- eval_tidy(vars, var_pos)
      df[, cols, drop = FALSE]
    }
    select(mtcars, -cyl)
    ```

1.  __<span style="color:red">Q</span>__: We can make `base::local()` slightly easier to understand by spreading
    out over multiple lines:

    ```{r}
    local3 <- function(expr, envir = new.env()) {
      call <- substitute(eval(quote(expr), envir))
      eval(call, envir = parent.frame())
    }
    ```
    
    Explain how `local()` works in words. (Hint: you might want to `print(call)`
    to help understand what `substitute()` is doing, and read the documentation
    to remind yourself what environment `new.env()` will inherit from.)
    
## Quosures

1.  __<span style="color:red">Q</span>__: Predict what evaluating each of the following quosures will return.

    ```{r}
    library(rlang)
    
    q1 <- new_quosure(expr(x), env(x = 1))
    q1
    
    q2 <- new_quosure(expr(x + !!q1), env(x = 10))
    q2
    
    q3 <- new_quosure(expr(x + !!q2), env(x = 100))
    q3
    ```
    
    __<span style="color:green">A</span>__: Each quosure will be evaluated in it's own environment. Hence we get:
    
    ```{r}
    eval_tidy(q1)
    eval_tidy(q2)
    eval_tidy(q3)
    ```

1.  __<span style="color:red">Q</span>__: Run this code in your head and predict what it will print. Confirm or 
    refute your prediction by running the code in R.

    ```{r, results = FALSE}
    f <- function(...) {
      x <- "f"
      g(f = x, ...)
    }
    g <- function(...) {
      x <- "g"
      h(g = x, ...)
    }
    h <- function(...) {
      enquos(...)
    }
    x <- "top"
    
    out <- f(top = x)
    out
    purrr::map_chr(out, eval_tidy)
    ```

## Tidy evaluation

1.  __<span style="color:red">Q</span>__: Improve `subset2()` to make it more like real subset function 
    (`subset.data.frame()`):
    
    * All drop rows where `subset` evaluates to `NA`
    * Give a clear error message if `subset` doesn't evalute to a logical vector
    * What happens if `subset` doesn't yield a logical vector with length
      equal to the number of rows in `data`? What do you think should happen?

1.  __<span style="color:red">Q</span>__: What happens if you use `expr()` instead of `enexpr()` inside of
    `subset2()`?

1.  __<span style="color:red">Q</span>__: Implement a form of `arrange()` where you can request a variable to 
    sorted in descending order using named arguments:
    
    ```{r, eval = FALSE}
    arrange(mtcars, cyl, desc = mpg, vs)
    ```
    
    (Hint:  The `descreasing` argument to `order()` will not help you. Instead,
    look at the definition of `dplyr::desc()`, and read the help for `xtfrm()`.)

1.  __<span style="color:red">Q</span>__: What does `transform()` do? Read the documentation. How does it work?
    Read the source code for `transform.data.frame()`. What does
    `substitute(list(...))` do?

1.  __<span style="color:red">Q</span>__: What does `with()` do? How does it work? Read the source code for
    `with.default()`. What does `within()` do? How does it work? Read the
    source code for `within.data.frame()`. Why is the code so much more
    complex than `with()`?

1.  __<span style="color:red">Q</span>__: Implement `with()` (code in `with.default()`).

1.  __<span style="color:red">Q</span>__: Implement a version of `within.data.frame()` that uses tidy evaluation.
    Read the documentation and make sure that you understand what `within()`
    does, then read the source code.

1.  __<span style="color:red">Q</span>__: Implement `transform()` (code in `transform.data.frame()`).  Extend it so that a
    variable can refer to the variables just defined.

## Case study: calling base NSE functions

### Exercises


## Capturing the current call {#capturing-call}

1.  __<span style="color:red">Q</span>__: Compare and contrast `update_model()` with `update.default()`.

1.  __<span style="color:red">Q</span>__: Why doesn't `write.csv(mtcars, "mtcars.csv", row = FALSE)` work?
    What property of argument matching has the original author forgotten?

1.  __<span style="color:red">Q</span>__: Rewrite `update.formula()` to use R code instead of C code.

1.  __<span style="color:red">Q</span>__: Sometimes it's necessary to uncover the function that called the
    function that called the current function (i.e., the grandparent, not
    the parent). How can you use `sys.call()` or `match.call()` to find
    this function?
